
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>thunder.TimeSeries</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.1.0/simplex/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5.0.RC1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.1.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="top" title="None" href="../index.html" />
    <link rel="up" title="API Reference" href="../api.html" />
    <link rel="next" title="thunder.SpatialSeries" href="thunder.SpatialSeries.html" />
    <link rel="prev" title="thunder.Images" href="thunder.Images.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html"><img src="../_static/thunder_logo.png">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>0.5.0.RC1</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="../tutorials.html">Tutorials</a></li>
                <li><a href="../api.html">API</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction to Thunder</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install_local.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install_ec2.html">Running on EC2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../style_guide.html">Style guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq.html">F.A.Q.</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/freeman-lab/thunder/releases">Release notes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/basic_usage.html">Basic usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/thunder_context.html">Thunder context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/input_formats.html">Input formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/images.html">Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/series.html">Series</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/multi_index.html">Multi-indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/clustering.html">Clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/factorization.html">Factorization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials/regression.html">Regression</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference external" href="https://gitter.im/thunder-project/thunder">Gitter chatroom</a></li>
<li class="toctree-l1"><a class="reference external" href="https://groups.google.com/forum/?hl=en#!forum/thunder-user">Mailing list</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/freeman-lab/thunder">Github repo</a></li>
<li class="toctree-l1"><a class="reference external" href="http://thefreemanlab.com/thunder/">Project page</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">thunder</span></tt>.TimeSeries</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="thunder-timeseries">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">thunder</span></tt>.TimeSeries<a class="headerlink" href="#thunder-timeseries" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="thunder.TimeSeries">
<em class="property">class </em><tt class="descclassname">thunder.</tt><tt class="descname">TimeSeries</tt><big>(</big><em>rdd</em>, <em>nrecords=None</em>, <em>dtype=None</em>, <em>index=None</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Distributed collection of time series data.</p>
<p>Backed by an RDD of key-value pairs where the key is an identifier
and the value is a one-dimensional array. The common index
specifies the time of each entry in the array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>rdd</strong> : RDD of (tuple, array) pairs</p>
<blockquote>
<div><p>RDD containing the series data.</p>
</div></blockquote>
<p><strong>index</strong> : array-like</p>
<blockquote>
<div><p>Time indices, must be same length as the arrays in the input data.
Defaults to arange(len(data)) if not provided.</p>
</div></blockquote>
<p><strong>dims</strong> : Dimensions</p>
<blockquote class="last">
<div><p>Specify the dimensions of the keys (min, max, and count), can
avoid computation if known in advance.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="thunder.Series.html#thunder.Series" title="thunder.Series"><tt class="xref py py-obj docutils literal"><span class="pre">Series</span></tt></a></dt>
<dd>base class for Series data</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">__init__</span></tt>(rdd[,&nbsp;nrecords,&nbsp;dtype,&nbsp;index,&nbsp;dims])</td>
<td></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.apply" title="thunder.TimeSeries.apply"><tt class="xref py py-obj docutils literal"><span class="pre">apply</span></tt></a>(func[,&nbsp;keepDtype,&nbsp;keepIndex])</td>
<td>Apply arbitrary function to records of a Data object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.applyKeys" title="thunder.TimeSeries.applyKeys"><tt class="xref py py-obj docutils literal"><span class="pre">applyKeys</span></tt></a>(func,&nbsp;**kwargs)</td>
<td>Apply arbitrary function to the keys of a Data object, preserving the values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.applyValues" title="thunder.TimeSeries.applyValues"><tt class="xref py py-obj docutils literal"><span class="pre">applyValues</span></tt></a>(func,&nbsp;**kwargs)</td>
<td>Apply arbitrary function to the values of a Data object, preserving the keys.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.astype" title="thunder.TimeSeries.astype"><tt class="xref py py-obj docutils literal"><span class="pre">astype</span></tt></a>(dtype[,&nbsp;casting])</td>
<td>Cast values to specified numpy dtype.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.between" title="thunder.TimeSeries.between"><tt class="xref py py-obj docutils literal"><span class="pre">between</span></tt></a>(left,&nbsp;right[,&nbsp;inclusive])</td>
<td>Select subset of values within the given index range</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.blockedAverage" title="thunder.TimeSeries.blockedAverage"><tt class="xref py py-obj docutils literal"><span class="pre">blockedAverage</span></tt></a>(blockLength)</td>
<td>Average blocks of a time series together, e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.cache" title="thunder.TimeSeries.cache"><tt class="xref py py-obj docutils literal"><span class="pre">cache</span></tt></a>()</td>
<td>Enable in-memory caching.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.center" title="thunder.TimeSeries.center"><tt class="xref py py-obj docutils literal"><span class="pre">center</span></tt></a>([axis])</td>
<td>Center series data by subtracting the mean</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.coalesce" title="thunder.TimeSeries.coalesce"><tt class="xref py py-obj docutils literal"><span class="pre">coalesce</span></tt></a>(numPartitions)</td>
<td>Coalesce data (used to reduce number of partitions).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.collect" title="thunder.TimeSeries.collect"><tt class="xref py py-obj docutils literal"><span class="pre">collect</span></tt></a>([sorting])</td>
<td>Return all records to the driver</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.collectAsArray" title="thunder.TimeSeries.collectAsArray"><tt class="xref py py-obj docutils literal"><span class="pre">collectAsArray</span></tt></a>([sorting])</td>
<td>Return all keys and values to the driver as a tuple of numpy arrays</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.collectKeysAsArray" title="thunder.TimeSeries.collectKeysAsArray"><tt class="xref py py-obj docutils literal"><span class="pre">collectKeysAsArray</span></tt></a>([sorting])</td>
<td>Return all values to the driver as a numpy array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.collectValuesAsArray" title="thunder.TimeSeries.collectValuesAsArray"><tt class="xref py py-obj docutils literal"><span class="pre">collectValuesAsArray</span></tt></a>([sorting])</td>
<td>Return all records to the driver as a numpy array</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.convolve" title="thunder.TimeSeries.convolve"><tt class="xref py py-obj docutils literal"><span class="pre">convolve</span></tt></a>(signal[,&nbsp;mode,&nbsp;var])</td>
<td>Conolve time series data against another signal</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.correlate" title="thunder.TimeSeries.correlate"><tt class="xref py py-obj docutils literal"><span class="pre">correlate</span></tt></a>(signal[,&nbsp;var])</td>
<td>Correlate series data against one or many one-dimensional arrays</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.count" title="thunder.TimeSeries.count"><tt class="xref py py-obj docutils literal"><span class="pre">count</span></tt></a>()</td>
<td>Calculates and returns the number of records in the RDD.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.crossCorr" title="thunder.TimeSeries.crossCorr"><tt class="xref py py-obj docutils literal"><span class="pre">crossCorr</span></tt></a>(signal[,&nbsp;lag,&nbsp;var])</td>
<td>Cross correlate time series data against another signal</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.detrend" title="thunder.TimeSeries.detrend"><tt class="xref py py-obj docutils literal"><span class="pre">detrend</span></tt></a>([method])</td>
<td>Detrend time series data with linear or nonlinear detrending</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.filter" title="thunder.TimeSeries.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(func)</td>
<td>Filter records by appliyng a function to each record.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.filterOnKeys" title="thunder.TimeSeries.filterOnKeys"><tt class="xref py py-obj docutils literal"><span class="pre">filterOnKeys</span></tt></a>(func)</td>
<td>Filter records by applying a function to keys</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.filterOnValues" title="thunder.TimeSeries.filterOnValues"><tt class="xref py py-obj docutils literal"><span class="pre">filterOnValues</span></tt></a>(func)</td>
<td>Filter records by applying a function to values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.first" title="thunder.TimeSeries.first"><tt class="xref py py-obj docutils literal"><span class="pre">first</span></tt></a>()</td>
<td>Return first record.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.fourier" title="thunder.TimeSeries.fourier"><tt class="xref py py-obj docutils literal"><span class="pre">fourier</span></tt></a>([freq])</td>
<td>Compute statistics of a Fourier decomposition on time series data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.get" title="thunder.TimeSeries.get"><tt class="xref py py-obj docutils literal"><span class="pre">get</span></tt></a>(key)</td>
<td>Returns a single value matching the passed key, or None if no matching keys found.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.getMany" title="thunder.TimeSeries.getMany"><tt class="xref py py-obj docutils literal"><span class="pre">getMany</span></tt></a>(keys)</td>
<td>Returns a sequence of values corresponding to the passed sequence of keys.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.getRange" title="thunder.TimeSeries.getRange"><tt class="xref py py-obj docutils literal"><span class="pre">getRange</span></tt></a>(sliceOrSlices)</td>
<td>Returns key/value pairs that fall within a range given by the passed slice or slices.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.indToSub" title="thunder.TimeSeries.indToSub"><tt class="xref py py-obj docutils literal"><span class="pre">indToSub</span></tt></a>([order,&nbsp;isOneBased,&nbsp;dims])</td>
<td>Convert linear indexing to subscript indexing</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.keys" title="thunder.TimeSeries.keys"><tt class="xref py py-obj docutils literal"><span class="pre">keys</span></tt></a>()</td>
<td>Return rdd of keys, ignoring values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.max" title="thunder.TimeSeries.max"><tt class="xref py py-obj docutils literal"><span class="pre">max</span></tt></a>()</td>
<td>Maximum of values, ignoring keys</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.maxProject" title="thunder.TimeSeries.maxProject"><tt class="xref py py-obj docutils literal"><span class="pre">maxProject</span></tt></a>([axis])</td>
<td>Project over one of the keys by taking a maximum</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.mean" title="thunder.TimeSeries.mean"><tt class="xref py py-obj docutils literal"><span class="pre">mean</span></tt></a>([dtype,&nbsp;casting])</td>
<td>Mean of values, ignoring keys</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.meanByRegions" title="thunder.TimeSeries.meanByRegions"><tt class="xref py py-obj docutils literal"><span class="pre">meanByRegions</span></tt></a>(nestedKeys[,&nbsp;validate])</td>
<td>Takes the mean of Series values within groupings specified by the passed keys.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.meanOfRegion" title="thunder.TimeSeries.meanOfRegion"><tt class="xref py py-obj docutils literal"><span class="pre">meanOfRegion</span></tt></a>(selection[,&nbsp;validate])</td>
<td>Takes the mean of Series values within a single region specified by the passed mask or keys.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.min" title="thunder.TimeSeries.min"><tt class="xref py py-obj docutils literal"><span class="pre">min</span></tt></a>()</td>
<td>Minimum of values, ignoring keys</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.normalize" title="thunder.TimeSeries.normalize"><tt class="xref py py-obj docutils literal"><span class="pre">normalize</span></tt></a>([baseline,&nbsp;window,&nbsp;perc])</td>
<td>Normalize each time series by subtracting and dividing by a baseline.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.pack" title="thunder.TimeSeries.pack"><tt class="xref py py-obj docutils literal"><span class="pre">pack</span></tt></a>([selection,&nbsp;sorting,&nbsp;transpose,&nbsp;dtype,&nbsp;...])</td>
<td>Pack a Series into a local array (e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.populateParamsFromFirstRecord" title="thunder.TimeSeries.populateParamsFromFirstRecord"><tt class="xref py py-obj docutils literal"><span class="pre">populateParamsFromFirstRecord</span></tt></a>()</td>
<td>Calls first() on the underlying rdd, using the returned record to determine appropriate attribute settings for this object (for instance, setting self.dtype to match the dtype of the underlying rdd records).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.query" title="thunder.TimeSeries.query"><tt class="xref py py-obj docutils literal"><span class="pre">query</span></tt></a>(inds[,&nbsp;var,&nbsp;order,&nbsp;isOneBased])</td>
<td>Extract records with indices matching those provided</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.repartition" title="thunder.TimeSeries.repartition"><tt class="xref py py-obj docutils literal"><span class="pre">repartition</span></tt></a>(numPartitions)</td>
<td>Repartition data.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.saveAsBinarySeries" title="thunder.TimeSeries.saveAsBinarySeries"><tt class="xref py py-obj docutils literal"><span class="pre">saveAsBinarySeries</span></tt></a>(outputDirPath[,&nbsp;overwrite])</td>
<td>Writes out Series-formatted data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.select" title="thunder.TimeSeries.select"><tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt></a>(crit)</td>
<td>Select subset of values that match a given index criterion</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.selectByIndex" title="thunder.TimeSeries.selectByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">selectByIndex</span></tt></a>(val[,&nbsp;level,&nbsp;squeeze,&nbsp;filter])</td>
<td>Select or filter elements of the Series by index values (across levels, if multi-index).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesAggregateByIndex" title="thunder.TimeSeries.seriesAggregateByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesAggregateByIndex</span></tt></a>(function[,&nbsp;level])</td>
<td>Aggregrate the data in each record, grouping by index values (across levels, if multi-index)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesCountByIndex" title="thunder.TimeSeries.seriesCountByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesCountByIndex</span></tt></a>([level])</td>
<td>Count the number of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMax" title="thunder.TimeSeries.seriesMax"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMax</span></tt></a>()</td>
<td>Compute the value maximum of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMaxByIndex" title="thunder.TimeSeries.seriesMaxByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMaxByIndex</span></tt></a>([level])</td>
<td>Compute maximum values of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMean" title="thunder.TimeSeries.seriesMean"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMean</span></tt></a>()</td>
<td>Compute the value mean of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMeanByIndex" title="thunder.TimeSeries.seriesMeanByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMeanByIndex</span></tt></a>([level])</td>
<td>Compute means of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMedian" title="thunder.TimeSeries.seriesMedian"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMedian</span></tt></a>()</td>
<td>Compute the value median of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMedianByIndex" title="thunder.TimeSeries.seriesMedianByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMedianByIndex</span></tt></a>([level])</td>
<td>Compute medians of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMin" title="thunder.TimeSeries.seriesMin"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMin</span></tt></a>()</td>
<td>Compute the value minimum of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesMinByIndex" title="thunder.TimeSeries.seriesMinByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesMinByIndex</span></tt></a>([level])</td>
<td>Compute minimum values of series elements for each unique index value (across level, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesPercentile" title="thunder.TimeSeries.seriesPercentile"><tt class="xref py py-obj docutils literal"><span class="pre">seriesPercentile</span></tt></a>(q)</td>
<td>Compute the value percentile of each record in a Series.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesStat" title="thunder.TimeSeries.seriesStat"><tt class="xref py py-obj docutils literal"><span class="pre">seriesStat</span></tt></a>(stat)</td>
<td>Compute a simple statistic for each record in a Series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesStatByIndex" title="thunder.TimeSeries.seriesStatByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesStatByIndex</span></tt></a>(stat[,&nbsp;level])</td>
<td>Compute the desired statistic for each uniue index values (across levels, if multi-index)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesStats" title="thunder.TimeSeries.seriesStats"><tt class="xref py py-obj docutils literal"><span class="pre">seriesStats</span></tt></a>()</td>
<td>Compute many statistics for each record in a Series</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesStdev" title="thunder.TimeSeries.seriesStdev"><tt class="xref py py-obj docutils literal"><span class="pre">seriesStdev</span></tt></a>()</td>
<td>Compute the value std of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesStdevByIndex" title="thunder.TimeSeries.seriesStdevByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesStdevByIndex</span></tt></a>([level])</td>
<td>Compute means of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.seriesSum" title="thunder.TimeSeries.seriesSum"><tt class="xref py py-obj docutils literal"><span class="pre">seriesSum</span></tt></a>()</td>
<td>Compute the value sum of each record in a Series</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.seriesSumByIndex" title="thunder.TimeSeries.seriesSumByIndex"><tt class="xref py py-obj docutils literal"><span class="pre">seriesSumByIndex</span></tt></a>([level])</td>
<td>Compute sums of series elements for each unique index value (across levels, if multi-index)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.sortByKey" title="thunder.TimeSeries.sortByKey"><tt class="xref py py-obj docutils literal"><span class="pre">sortByKey</span></tt></a>()</td>
<td>Sort records by keys.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.squelch" title="thunder.TimeSeries.squelch"><tt class="xref py py-obj docutils literal"><span class="pre">squelch</span></tt></a>(threshold)</td>
<td>Set all records that do not exceed the given threhsold to 0</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.standardize" title="thunder.TimeSeries.standardize"><tt class="xref py py-obj docutils literal"><span class="pre">standardize</span></tt></a>([axis])</td>
<td>Standardize series data by dividing by the standard deviation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.stats" title="thunder.TimeSeries.stats"><tt class="xref py py-obj docutils literal"><span class="pre">stats</span></tt></a>([requestedStats,&nbsp;dtype,&nbsp;casting])</td>
<td>Return a L{StatCounter} object that captures all or some of the mean, variance, maximum, minimum, and count of the RDD&#8217;s elements in one operation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.stdev" title="thunder.TimeSeries.stdev"><tt class="xref py py-obj docutils literal"><span class="pre">stdev</span></tt></a>([dtype,&nbsp;casting])</td>
<td>Standard deviation of values, ignoring keys</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.subToInd" title="thunder.TimeSeries.subToInd"><tt class="xref py py-obj docutils literal"><span class="pre">subToInd</span></tt></a>([order,&nbsp;isOneBased])</td>
<td>Convert subscript index keys to linear index keys</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.subsample" title="thunder.TimeSeries.subsample"><tt class="xref py py-obj docutils literal"><span class="pre">subsample</span></tt></a>([sampleFactor])</td>
<td>Subsample time series by an integer factor</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.subset" title="thunder.TimeSeries.subset"><tt class="xref py py-obj docutils literal"><span class="pre">subset</span></tt></a>([nsamples,&nbsp;thresh,&nbsp;stat])</td>
<td>Extract random subset of records, filtering on a summary statistic.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.sum" title="thunder.TimeSeries.sum"><tt class="xref py py-obj docutils literal"><span class="pre">sum</span></tt></a>([dtype,&nbsp;casting])</td>
<td>Sum of values, ignoring keys</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.take" title="thunder.TimeSeries.take"><tt class="xref py py-obj docutils literal"><span class="pre">take</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Take samples.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.toBlocks" title="thunder.TimeSeries.toBlocks"><tt class="xref py py-obj docutils literal"><span class="pre">toBlocks</span></tt></a>([size])</td>
<td>Converts Series to Blocks.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.toImages" title="thunder.TimeSeries.toImages"><tt class="xref py py-obj docutils literal"><span class="pre">toImages</span></tt></a>([size])</td>
<td>Converts Series to Images.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.toRowMatrix" title="thunder.TimeSeries.toRowMatrix"><tt class="xref py py-obj docutils literal"><span class="pre">toRowMatrix</span></tt></a>()</td>
<td>Convert Series to RowMatrix</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.toSpatialSeries" title="thunder.TimeSeries.toSpatialSeries"><tt class="xref py py-obj docutils literal"><span class="pre">toSpatialSeries</span></tt></a>()</td>
<td>Convert Series to SpatialSeries</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.toTimeSeries" title="thunder.TimeSeries.toTimeSeries"><tt class="xref py py-obj docutils literal"><span class="pre">toTimeSeries</span></tt></a>()</td>
<td>Convert Series to TimeSeries</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.triggeredAverage" title="thunder.TimeSeries.triggeredAverage"><tt class="xref py py-obj docutils literal"><span class="pre">triggeredAverage</span></tt></a>(events[,&nbsp;lag])</td>
<td>Construct an average time series triggered on each of several events,</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.values" title="thunder.TimeSeries.values"><tt class="xref py py-obj docutils literal"><span class="pre">values</span></tt></a>()</td>
<td>Return rdd of values, ignoring keys</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#thunder.TimeSeries.variance" title="thunder.TimeSeries.variance"><tt class="xref py py-obj docutils literal"><span class="pre">variance</span></tt></a>([dtype,&nbsp;casting])</td>
<td>Variance of values, ignoring keys</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#thunder.TimeSeries.zscore" title="thunder.TimeSeries.zscore"><tt class="xref py py-obj docutils literal"><span class="pre">zscore</span></tt></a>([axis])</td>
<td>Zscore series data by subtracting the mean and</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="thunder.TimeSeries.apply">
<tt class="descname">apply</tt><big>(</big><em>func</em>, <em>keepDtype=False</em>, <em>keepIndex=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply arbitrary function to records of a Data object.</p>
<p>This wraps the combined process of calling Spark&#8217;s map operation on
the underlying RDD and returning a reconstructed Data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func</strong> : function</p>
<blockquote>
<div><p>Function to apply to records.</p>
</div></blockquote>
<p><strong>keepDtype</strong> : boolean</p>
<blockquote>
<div><p>Whether to preserve the dtype, if false dtype will be set to none
under the assumption that the function might change it</p>
</div></blockquote>
<p><strong>keepIndex</strong> : boolean</p>
<blockquote class="last">
<div><p>Whether to preserve the index, if false index will be set to none
under the assumption that the function might change it</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.applyKeys">
<tt class="descname">applyKeys</tt><big>(</big><em>func</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.applyKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply arbitrary function to the keys of a Data object, preserving the values.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="thunder.Series.html#thunder.Series.apply" title="thunder.Series.apply"><tt class="xref py py-obj docutils literal"><span class="pre">Series.apply</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.applyValues">
<tt class="descname">applyValues</tt><big>(</big><em>func</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.applyValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply arbitrary function to the values of a Data object, preserving the keys.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="thunder.Series.html#thunder.Series.apply" title="thunder.Series.apply"><tt class="xref py py-obj docutils literal"><span class="pre">Series.apply</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.astype">
<tt class="descname">astype</tt><big>(</big><em>dtype</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast values to specified numpy dtype.</p>
<p>If &#8216;smallfloat&#8217; is passed, values will be cast to the smallest floating point representation
to which they can be cast safely, as determined by the thunder.utils.common smallest_float_type function.
Typically this will be a float type larger than a passed integer type (for instance, float16 for int8 or uint8).</p>
<p>If the passed dtype is the same as the current dtype, or if &#8216;smallfloat&#8217; is passed when values are already
in floating point, then this method will return self unchanged.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dtype: numpy dtype or dtype specifier, or string &#8216;smallfloat&#8217;, or None</strong></p>
<blockquote>
<div><p>Data type to which RDD values are to be cast. Will return without cast if None is passed.</p>
</div></blockquote>
<p><strong>casting: &#8216;no&#8217;|&#8217;equiv&#8217;|&#8217;safe&#8217;|&#8217;same_kind&#8217;|&#8217;unsafe&#8217;, optional, default &#8216;safe&#8217;</strong></p>
<blockquote>
<div><p>Casting method to pass on to numpy&#8217;s astype() method; see numpy documentation for details.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">New Data object, of same type as self, with values cast to the requested dtype; or self if no cast is performed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.between">
<tt class="descname">between</tt><big>(</big><em>left</em>, <em>right</em>, <em>inclusive=True</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.between" title="Permalink to this definition">¶</a></dt>
<dd><p>Select subset of values within the given index range</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>left</strong> : int</p>
<blockquote>
<div><p>Left-most index in the desired range</p>
</div></blockquote>
<p><strong>right: int</strong></p>
<blockquote>
<div><p>Right-most index in the desired range</p>
</div></blockquote>
<p><strong>inclusive</strong> : boolean, optional, default = True</p>
<blockquote class="last">
<div><p>Whether selection should include bounds</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.blockedAverage">
<tt class="descname">blockedAverage</tt><big>(</big><em>blockLength</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.blockedAverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Average blocks of a time series together, e.g. because they correspond
to trials of some repeated measurement or process</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>triallength</strong> : int</p>
<blockquote class="last">
<div><p>Length of trial, must divide evenly into total length of time series</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.cache">
<tt class="descname">cache</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable in-memory caching.</p>
<p>This calls the Spark cache() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.center">
<tt class="descname">center</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Center series data by subtracting the mean
either within or across records</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int, optional, default = 0</p>
<blockquote class="last">
<div><p>Which axis to center along, rows (0) or columns (1)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.coalesce">
<tt class="descname">coalesce</tt><big>(</big><em>numPartitions</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.coalesce" title="Permalink to this definition">¶</a></dt>
<dd><p>Coalesce data (used to reduce number of partitions).</p>
<p>This calls the Spark coalesce() method on the underlying RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>numPartitions</strong> : int</p>
<blockquote class="last">
<div><p>Number of partitions in coalesced RDD</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.collect">
<tt class="descname">collect</tt><big>(</big><em>sorting=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all records to the driver</p>
<p>This will be slow for large datasets, and may exhaust the available memory on the driver.</p>
<p>This calls the Spark collect() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.collectAsArray">
<tt class="descname">collectAsArray</tt><big>(</big><em>sorting=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.collectAsArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all keys and values to the driver as a tuple of numpy arrays</p>
<p>This will be slow for large datasets, and may exhaust the available memory on the driver.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.collectKeysAsArray">
<tt class="descname">collectKeysAsArray</tt><big>(</big><em>sorting=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.collectKeysAsArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all values to the driver as a numpy array</p>
<p>This will be slow for large datasets, and may exhaust the available memory on the driver.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.collectValuesAsArray">
<tt class="descname">collectValuesAsArray</tt><big>(</big><em>sorting=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.collectValuesAsArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all records to the driver as a numpy array</p>
<p>This will be slow for large datasets, and may exhaust the available memory on the driver.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.convolve">
<tt class="descname">convolve</tt><big>(</big><em>signal</em>, <em>mode='full'</em>, <em>var=None</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Conolve time series data against another signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signal</strong> : array, or str</p>
<blockquote>
<div><p>Signal to convolve with, can be a numpy array or a
MAT file containing the signal as a variable</p>
</div></blockquote>
<p><strong>var</strong> : str</p>
<blockquote>
<div><p>Variable name if loading from a MAT file</p>
</div></blockquote>
<p><strong>mode</strong> : str, optional, default=&#8217;full&#8217;</p>
<blockquote class="last">
<div><p>Mode of convolution, options are &#8216;full&#8217;, &#8216;same&#8217;, and &#8216;same&#8217;</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.correlate">
<tt class="descname">correlate</tt><big>(</big><em>signal</em>, <em>var='s'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.correlate" title="Permalink to this definition">¶</a></dt>
<dd><p>Correlate series data against one or many one-dimensional arrays</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signal</strong> : array, or str</p>
<blockquote>
<div><p>Signal(s) to correlate against, can be a numpy array or a
MAT file containing the signal as a variable</p>
</div></blockquote>
<p><strong>var</strong> : str</p>
<blockquote class="last">
<div><p>Variable name if loading from a MAT file</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.count">
<tt class="descname">count</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the number of records in the RDD.</p>
<p>This calls the Spark count() method on the underlying RDD and updates
the .nrecords metadata attribute.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.crossCorr">
<tt class="descname">crossCorr</tt><big>(</big><em>signal</em>, <em>lag=0</em>, <em>var=None</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.crossCorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Cross correlate time series data against another signal</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>signal</strong> : array, or str</p>
<blockquote>
<div><p>Signal to correlate against, can be a numpy array or a
MAT file containing the signal as a variable</p>
</div></blockquote>
<p><strong>var</strong> : str</p>
<blockquote>
<div><p>Variable name if loading from a MAT file</p>
</div></blockquote>
<p><strong>lag</strong> : int</p>
<blockquote class="last">
<div><p>Range of lags to consider, will cover (-lag, +lag)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.detrend">
<tt class="descname">detrend</tt><big>(</big><em>method='linear'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.detrend" title="Permalink to this definition">¶</a></dt>
<dd><p>Detrend time series data with linear or nonlinear detrending
Preserve intercept so that subsequent steps can adjust the baseline</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>method</strong> : str, optional, default = &#8216;linear&#8217;</p>
<blockquote>
<div><p>Detrending method</p>
</div></blockquote>
<p><strong>order</strong> : int, optional, default = 5</p>
<blockquote class="last">
<div><p>Order of polynomial, for non-linear detrending only</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.filter">
<tt class="descname">filter</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter records by appliyng a function to each record.</p>
<p>This calls the Spark filter() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.filterOnKeys">
<tt class="descname">filterOnKeys</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.filterOnKeys" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter records by applying a function to keys</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.filterOnValues">
<tt class="descname">filterOnValues</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.filterOnValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Filter records by applying a function to values</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.first">
<tt class="descname">first</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Return first record.</p>
<p>This calls the Spark first() method on the underlying RDD. As a side effect, any attributes on this object that
can be set based on the values of the first record will be set (see populateParamsFromFirstRecord).</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.fourier">
<tt class="descname">fourier</tt><big>(</big><em>freq=None</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.fourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute statistics of a Fourier decomposition on time series data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>freq</strong> : int</p>
<blockquote class="last">
<div><p>Digital frequency at which to compute coherence and phase</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.get">
<tt class="descname">get</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a single value matching the passed key, or None if no matching keys found.</p>
<p>If multiple records are found with keys matching the passed key, a sequence of all matching
values will be returned.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.getMany">
<tt class="descname">getMany</tt><big>(</big><em>keys</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.getMany" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sequence of values corresponding to the passed sequence of keys.</p>
<p>The return value will be a sequence equal in length to the passed keys, with each
value in the returned sequence corresponding to the key at the same position in the passed
keys sequence. If no value is found for a given key, the corresponding sequence element will be None.
If multiple values are found, a sequence containing all matching values will be returned.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.getRange">
<tt class="descname">getRange</tt><big>(</big><em>sliceOrSlices</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.getRange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns key/value pairs that fall within a range given by the passed slice or slices.</p>
<p>The return values will be a sorted list of key/value pairs of all records in the underlying
RDD for which the key falls within the range given by the passed slice selectors. Note that
this may be very large, and could potentially exhaust the available memory on the driver.</p>
<p>For singleton keys, a single slice (or slice sequence of length one) should be passed.
For tuple keys, a sequence of multiple slices should be passed. A <cite>step</cite> attribute on slices
is not supported and a alueError will be raised if passed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sliceOrSlices: slice object or sequence of slices</strong></p>
<blockquote>
<div><p>The passed slice or slices should be of the same cardinality as the keys of the underlying rdd.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sorted sequence of key/value pairs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.indToSub">
<tt class="descname">indToSub</tt><big>(</big><em>order='F'</em>, <em>isOneBased=True</em>, <em>dims=None</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.indToSub" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert linear indexing to subscript indexing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : array-like, optional</p>
<blockquote>
<div><p>Maximum dimensions. If not provided, will use dims property.</p>
</div></blockquote>
<p><strong>order</strong> : str, &#8216;C&#8217; or &#8216;F&#8217;, default = &#8216;F&#8217;</p>
<blockquote>
<div><p>Specifies row-major or column-major array indexing. See numpy.unravel_index.</p>
</div></blockquote>
<p><strong>onebased</strong> : boolean, default = True</p>
<blockquote class="last">
<div><p>True if generated subscript indices are to start at 1, False to start at 0</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return rdd of keys, ignoring values</p>
<p>This calls the Spark keys() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.max">
<tt class="descname">max</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum of values, ignoring keys</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.maxProject">
<tt class="descname">maxProject</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.maxProject" title="Permalink to this definition">¶</a></dt>
<dd><p>Project over one of the keys by taking a maximum</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.mean">
<tt class="descname">mean</tt><big>(</big><em>dtype='float64'</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean of values, ignoring keys</p>
<p>If dtype is not None, then the values will first be cast to the requested
type before the operation is performed. See Data.astype() for details.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.meanByRegions">
<tt class="descname">meanByRegions</tt><big>(</big><em>nestedKeys</em>, <em>validate=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.meanByRegions" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the mean of Series values within groupings specified by the passed keys.</p>
<p>Each sequence of keys passed specifies a &#8220;region&#8221; within which to calculate the mean. For instance,
series.meanByRegion([[(1,0), (2,0)]) would return the mean of the records in series with keys (1,0) and (2,0).
If multiple regions are passed in, then multiple aggregates will be returned. For instance,
series.meanByRegion([[(1,0), (2,0)], [(1,0), (3,0)]]) would return two means, one for the region composed
of records (1,0) and (2,0), the other for records (1,0) and (3,0).</p>
<p>Alternatively, an ndarray mask may be passed instead of a sequence of sequences of keys. The array mask
must be the same shape as the underlying series data (that is, nestedKeys.shape == series.dims.count must
be True). If an integer or unsigned integer mask is passed, then each unique nonzero element in the passed
mask will be interpreted as a separate region (that is, all &#8216;1&#8217;s will be a single region, as will all &#8216;2&#8217;s,
and so on). If another type of ndarray is passed, then all nonzero mask elements will be interpreted
as a single region.</p>
<p>This method returns a new Series object, with one record per defined region. Record keys will be the mean of
keys within the region, while record values will be the mean of values in the region. The <cite>dims</cite> attribute on
the new Series will not be set; all other attributes will be as in the source Series object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nestedKeys: sequence of sequences of Series record keys, or ndarray mask</strong></p>
<blockquote>
<div><p>Specification of regions over which to compute means.</p>
</div></blockquote>
<p><strong>validate: boolean, default False</strong></p>
<blockquote>
<div><p>Whether to check that all requested records were included in the mean. If True,
exceptions will be thrown on workers if the number of records per region
is not equal to the number specificed by the selection.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">new Series object</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.meanOfRegion">
<tt class="descname">meanOfRegion</tt><big>(</big><em>selection</em>, <em>validate=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.meanOfRegion" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the mean of Series values within a single region specified by the passed mask or keys.</p>
<p>The region, defined as a group of keys, may be specified either by a mask array, or directly by
Series keys. If an ndarray is passed as <cite>selection</cite>, then the mean will be taken across all series
records corresponding to nonzero elements of the passed mask. (The passed ndarray must have the
same shape as series.dims.count, otherwise a ValueError will be thrown.)</p>
<p>If a sequence of record keys is passed, the the mean will be taken across all records
with keys matching one of those in the passed selection sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>selection</strong> : sequence of tuples, or ndarray mask</p>
<blockquote>
<div><p>The region over which to compute a mean as specified by a set of keys, or a ndarray mask.</p>
</div></blockquote>
<p><strong>validate</strong> : boolean, default False</p>
<blockquote>
<div><p>Whether to check that all requested records were included in the mean. If True,
ValueError will be thrown if the number included is not equal to the number specified.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple of (tuple(mean of keys), array(mean value)), or (None, None) if no matching records are found</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.min">
<tt class="descname">min</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum of values, ignoring keys</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.normalize">
<tt class="descname">normalize</tt><big>(</big><em>baseline='percentile'</em>, <em>window=None</em>, <em>perc=20</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalize each time series by subtracting and dividing by a baseline.</p>
<p>Baseline can be derived from a global mean or percentile,
or a smoothed percentile estimated within a rolling window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>baseline</strong> : str, optional, default = &#8216;percentile&#8217;</p>
<blockquote>
<div><p>Quantity to use as the baseline, options are &#8216;mean&#8217;, &#8216;percentile&#8217;, &#8216;window&#8217;, or &#8216;window-fast&#8217;</p>
</div></blockquote>
<p><strong>window</strong> : int, optional, default = 6</p>
<blockquote>
<div><p>Size of window for baseline estimation, for &#8216;window&#8217; and &#8216;window-fast&#8217; baseline only</p>
</div></blockquote>
<p><strong>perc</strong> : int, optional, default = 20</p>
<blockquote class="last">
<div><p>Percentile value to use, for &#8216;percentile&#8217;, &#8216;window&#8217;, or &#8216;window-fast&#8217; baseline only</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.pack">
<tt class="descname">pack</tt><big>(</big><em>selection=None</em>, <em>sorting=False</em>, <em>transpose=False</em>, <em>dtype=None</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.pack" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack a Series into a local array (e.g. for saving)</p>
<p>This operation constructs a multidimensional numpy array from the values in this Series object,
with indexing into the returned array as implied by the Series RDD keys. The returned numpy
array will be local to the Spark driver; the data set should be filtered down to a reasonable
size (such as by seriesMean(), select(), or the <cite>selection</cite> parameter) before attempting to
pack() a large data set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>selection</strong> : function, list, str, or int, optional, default None</p>
<blockquote>
<div><p>Criterion for selecting a subset, list, or index value</p>
</div></blockquote>
<p><strong>sorting</strong> : boolean, optional, default False</p>
<blockquote>
<div><p>Whether to sort the local array based on the keys. In most cases the returned array will
already be ordered correctly, and so an explicit sorting=True is typically not necessary.</p>
</div></blockquote>
<p><strong>transpose</strong> : boolean, optional, default False</p>
<blockquote>
<div><p>Transpose the spatial dimensions of the returned array.</p>
</div></blockquote>
<p><strong>dtype: numpy dtype, dtype specifier, or string &#8216;smallfloat&#8217;. optional, default None.</strong></p>
<blockquote>
<div><p>If present, will cast the values to the requested dtype before collecting on the driver. See Data.astype()
and numpy&#8217;s astype() function for details.</p>
</div></blockquote>
<p><strong>casting: casting: &#8216;no&#8217;|&#8217;equiv&#8217;|&#8217;safe&#8217;|&#8217;same_kind&#8217;|&#8217;unsafe&#8217;, optional, default &#8216;safe&#8217;</strong></p>
<blockquote>
<div><p>Casting method to pass on to numpy&#8217;s astype() method if dtype is given; see numpy documentation for details.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">result: numpy array</p>
<blockquote class="last">
<div><p>An array with dimensionality inferred from the RDD keys. Data in an individual Series
value will be placed into this returned array by interpreting the Series keys as indicies
into the returned array. The shape of the returned array will be (num time points x spatial shape).
For instance, a series derived from 4 2d images, each 64 x 128, will have dims.count==(64, 128)
and will pack into an array with shape (4, 64, 128). If transpose is true, the spatial dimensions
will be reversed, so that in this example the shape of the returned array will be (4, 128, 64).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.populateParamsFromFirstRecord">
<tt class="descname">populateParamsFromFirstRecord</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.populateParamsFromFirstRecord" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls first() on the underlying rdd, using the returned record to determine appropriate attribute settings
for this object (for instance, setting self.dtype to match the dtype of the underlying rdd records).</p>
<p>Returns the result of calling self.rdd.first().</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.query">
<tt class="descname">query</tt><big>(</big><em>inds</em>, <em>var='inds'</em>, <em>order='F'</em>, <em>isOneBased=True</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract records with indices matching those provided</p>
<p>Keys will be automatically linearized before matching to provided indices.
This will not affect</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>inds</strong> : str, or array-like (2D)</p>
<blockquote>
<div><p>Array of indices, each an array-like of integer indices, or
filename of a MAT file containing a set of indices as a cell array</p>
</div></blockquote>
<p><strong>var</strong> : str, optional, default = &#8216;inds&#8217;</p>
<blockquote>
<div><p>Variable name if loading from a MAT file</p>
</div></blockquote>
<p><strong>order</strong> : str, optional, default = &#8216;F&#8217;</p>
<blockquote>
<div><p>Specify ordering for linearizing indices (see subtoind)</p>
</div></blockquote>
<p><strong>onebased</strong> : boolean, optional, default = True</p>
<blockquote>
<div><p>Specify zero or one based indexing for linearizing (see subtoind)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>keys</strong> : array, shape (n, k) where k is the length of each value</p>
<blockquote>
<div><p>Averaged values</p>
</div></blockquote>
<p><strong>values</strong> : array, shape (n, d) where d is the number of keys</p>
<blockquote class="last">
<div><p>Averaged keys</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.repartition">
<tt class="descname">repartition</tt><big>(</big><em>numPartitions</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Repartition data.</p>
<p>This calls the Spark repartition() method on the underlying RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>numPartitions</strong> : int</p>
<blockquote class="last">
<div><p>Number of partitions in new RDD</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.saveAsBinarySeries">
<tt class="descname">saveAsBinarySeries</tt><big>(</big><em>outputDirPath</em>, <em>overwrite=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.saveAsBinarySeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes out Series-formatted data.</p>
<p>This method (Series.saveAsBinarySeries) writes out binary series files using the current partitioning
of this Series object. (That is, if mySeries.rdd.getNumPartitions() == 5, then 5 files will be written
out, one per partition.) The records will not be resorted; the file names for each partition will be
taken from the key of the first Series record in that partition. If the Series object is already
sorted and no records have been removed by filtering, then the resulting output should be equivalent
to what one would get from calling myImages.saveAsBinarySeries().</p>
<p>If all one wishes to do is to save out Images data in a binary series format, then
tsc.convertImagesToSeries() will likely be more efficient than
tsc.loadImages().toSeries().saveAsBinarySeries().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>outputDirPath</strong> : string path or URI to directory to be created</p>
<blockquote>
<div><p>Output files will be written underneath outputdirname. This directory must not yet exist
(unless overwrite is True), and must be no more than one level beneath an existing directory.
It will be created as a result of this call.</p>
</div></blockquote>
<p><strong>overwrite</strong> : bool</p>
<blockquote class="last">
<div><p>If true, outputdirname and all its contents will be deleted and recreated as part
of this call.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.select">
<tt class="descname">select</tt><big>(</big><em>crit</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.select" title="Permalink to this definition">¶</a></dt>
<dd><p>Select subset of values that match a given index criterion</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>crit</strong> : function, list, str, int</p>
<blockquote class="last">
<div><p>Criterion function to apply to indices, specific index value,
or list of indices</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.selectByIndex">
<tt class="descname">selectByIndex</tt><big>(</big><em>val</em>, <em>level=0</em>, <em>squeeze=False</em>, <em>filter=False</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.selectByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Select or filter elements of the Series by index values (across levels, if multi-index).</p>
<p>The index is a property of a Series object that assigns a value to each position within
the arrays stored in the records of the Series. This function returns a new Series where,
within each record, only the elements indexed by a given value(s) are retained. An index
where each value is a list of a fixed length is referred to as a &#8216;multi-index&#8217;,
as it provides multiple labels for each index location. Each of the dimensions in these
sublists is a &#8216;level&#8217; of the multi-index. If the index of the Series is a multi-index, then
the selection can proceed by first selecting one or more levels, and then selecting one
or more values at each level.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesAggregateByIndex">
<tt class="descname">seriesAggregateByIndex</tt><big>(</big><em>function</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesAggregateByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregrate the data in each record, grouping by index values (across levels, if multi-index)</p>
<p>For each unique value of the index, applies a function to the group of elements of the RDD indexed by that
value. Returns an RDD indexed by those unique values. For the result to be a valid Series object, the 
aggregating function should return a simple numeric type. Also allows selection of levels within a 
multi-index. See selectByIndex doc for more info on indices and multi-indices.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesCountByIndex">
<tt class="descname">seriesCountByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesCountByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMax">
<tt class="descname">seriesMax</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMax" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value maximum of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMaxByIndex">
<tt class="descname">seriesMaxByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMaxByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute maximum values of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMean">
<tt class="descname">seriesMean</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value mean of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMeanByIndex">
<tt class="descname">seriesMeanByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMeanByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute means of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMedian">
<tt class="descname">seriesMedian</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMedian" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value median of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMedianByIndex">
<tt class="descname">seriesMedianByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMedianByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute medians of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMin">
<tt class="descname">seriesMin</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMin" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value minimum of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesMinByIndex">
<tt class="descname">seriesMinByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesMinByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute minimum values of series elements for each unique index value (across level, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesPercentile">
<tt class="descname">seriesPercentile</tt><big>(</big><em>q</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesPercentile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value percentile of each record in a Series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>q</strong> : scalar</p>
<blockquote class="last">
<div><p>Floating point number between 0 and 100 inclusive, specifying percentile.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesStat">
<tt class="descname">seriesStat</tt><big>(</big><em>stat</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesStat" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a simple statistic for each record in a Series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>stat</strong> : str</p>
<blockquote class="last">
<div><p>Which statistic to compute</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesStatByIndex">
<tt class="descname">seriesStatByIndex</tt><big>(</big><em>stat</em>, <em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesStatByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the desired statistic for each uniue index values (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesStats">
<tt class="descname">seriesStats</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesStats" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute many statistics for each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesStdev">
<tt class="descname">seriesStdev</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesStdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value std of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesStdevByIndex">
<tt class="descname">seriesStdevByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesStdevByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute means of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesSum">
<tt class="descname">seriesSum</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesSum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the value sum of each record in a Series</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.seriesSumByIndex">
<tt class="descname">seriesSumByIndex</tt><big>(</big><em>level=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.seriesSumByIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute sums of series elements for each unique index value (across levels, if multi-index)</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.sortByKey">
<tt class="descname">sortByKey</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.sortByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort records by keys.</p>
<p>This calls the Spark sortByKey() method on the underlying RDD, but reverse the order
of the key tuples before and after sorting so they are sorted according to the convention
that the first key varies fastest, then the second, then the third, etc.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.squelch">
<tt class="descname">squelch</tt><big>(</big><em>threshold</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.squelch" title="Permalink to this definition">¶</a></dt>
<dd><p>Set all records that do not exceed the given threhsold to 0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>threshold</strong> : scalar</p>
<blockquote class="last">
<div><p>Level below which to set records to zero</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.standardize">
<tt class="descname">standardize</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize series data by dividing by the standard deviation
either within or across records</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int, optional, default = 0</p>
<blockquote class="last">
<div><p>Which axis to standardize along, rows (0) or columns (1)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.stats">
<tt class="descname">stats</tt><big>(</big><em>requestedStats='all'</em>, <em>dtype='float64'</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a L{StatCounter} object that captures all or some of the mean, variance, maximum, minimum,
and count of the RDD&#8217;s elements in one operation.</p>
<p>If dtype is specified and not None, will first cast the data as described in Data.astype().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>requestedStats: sequence of one or more requested stats, or &#8216;all&#8217;</strong></p>
<blockquote>
<div><p>Possible stats include &#8216;mean&#8217;, &#8216;sum&#8217;, &#8216;min&#8217;, &#8216;max&#8217;, &#8216;variance&#8217;, &#8216;sampleVariance&#8217;, &#8216;stdev&#8217;, &#8216;sampleStdev&#8217;.</p>
</div></blockquote>
<p><strong>dtype: numpy dtype or dtype specifier, or string &#8216;smallfloat&#8217;, or None</strong></p>
<blockquote>
<div><p>Data type to which RDD values are to be cast before calculating stats. See Data.astype().</p>
</div></blockquote>
<p><strong>casting: &#8216;no&#8217;|&#8217;equiv&#8217;|&#8217;safe&#8217;|&#8217;same_kind&#8217;|&#8217;unsafe&#8217;, optional, default &#8216;safe&#8217;</strong></p>
<blockquote class="last">
<div><p>Method of casting to use. See Data.astype() and numpy astype() function.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.stdev">
<tt class="descname">stdev</tt><big>(</big><em>dtype='float64'</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard deviation of values, ignoring keys</p>
<p>If dtype is not None, then the values will first be cast to the requested type before the operation is
performed. See Data.astype() for details.</p>
<p>obj.stdev() is equivalent to obj.astype(dtype, casting).rdd.values().stdev().</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.subToInd">
<tt class="descname">subToInd</tt><big>(</big><em>order='F'</em>, <em>isOneBased=True</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.subToInd" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert subscript index keys to linear index keys</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>order</strong> : str, &#8216;C&#8217; or &#8216;F&#8217;, default = &#8216;F&#8217;</p>
<blockquote>
<div><p>Specifies row-major or column-major array indexing. See numpy.ravel_multi_index.</p>
</div></blockquote>
<p><strong>isOneBased</strong> : boolean, default = True</p>
<blockquote class="last">
<div><p>True if subscript indices start at 1, False if they start at 0</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.subsample">
<tt class="descname">subsample</tt><big>(</big><em>sampleFactor=2</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.subsample" title="Permalink to this definition">¶</a></dt>
<dd><p>Subsample time series by an integer factor</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sampleFactor</strong> : positive integer, optional, default=2</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.subset">
<tt class="descname">subset</tt><big>(</big><em>nsamples=100</em>, <em>thresh=None</em>, <em>stat='std'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract random subset of records, filtering on a summary statistic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nsamples</strong> : int, optional, default = 100</p>
<blockquote>
<div><p>The number of data points to sample</p>
</div></blockquote>
<p><strong>thresh</strong> : float, optional, default = None</p>
<blockquote>
<div><p>A threshold on statistic to use when picking points</p>
</div></blockquote>
<p><strong>stat</strong> : str, optional, default = &#8216;std&#8217;</p>
<blockquote>
<div><p>Statistic to use for thresholding</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : array</p>
<blockquote class="last">
<div><p>A local numpy array with the subset of points</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.sum">
<tt class="descname">sum</tt><big>(</big><em>dtype='float64'</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of values, ignoring keys</p>
<p>If dtype is not None, then the values will first be cast to the requested type before the operation is
performed. See Data.astype() for details.</p>
<p>obj.sum() is equivalent to obj.astype(dtype, casting).rdd.values().sum().</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.take">
<tt class="descname">take</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take samples.</p>
<p>This calls the Spark take() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.toBlocks">
<tt class="descname">toBlocks</tt><big>(</big><em>size='150M'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.toBlocks" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts Series to Blocks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : string memory size, tuple of splits per dimension, or instance of BlockingStrategy</p>
<blockquote>
<div><p>String interpreted as memory size (e.g. &#8220;64M&#8221;). Tuple of ints interpreted as
&#8220;pixels per dimension&#8221; (default) or &#8220;splits per dimension&#8221;, depending on units.
Instance of BlockingStrategy can be passed directly.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Blocks instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.toImages">
<tt class="descname">toImages</tt><big>(</big><em>size='150M'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.toImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts Series to Images.</p>
<p>Equivalent to calling series.toBlocks(size).toImages()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : string memory size, optional, default = &#8220;150M&#8221;</p>
<blockquote>
<div><p>String interpreted as memory size (e.g. &#8220;64M&#8221;).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Images instance</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.toRowMatrix">
<tt class="descname">toRowMatrix</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.toRowMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series to RowMatrix</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.toSpatialSeries">
<tt class="descname">toSpatialSeries</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.toSpatialSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series to SpatialSeries</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.toTimeSeries">
<tt class="descname">toTimeSeries</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.toTimeSeries" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series to TimeSeries</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.triggeredAverage">
<tt class="descname">triggeredAverage</tt><big>(</big><em>events</em>, <em>lag=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.triggeredAverage" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an average time series triggered on each of several events,
considering a range of lags before and after the event</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>events</strong> : array-like</p>
<blockquote>
<div><p>List of events to trigger on</p>
</div></blockquote>
<p><strong>lag</strong> : int</p>
<blockquote class="last">
<div><p>Range of lags to consider, will cover (-lag, +lag)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#thunder.TimeSeries.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return rdd of values, ignoring keys</p>
<p>This calls the Spark values() method on the underlying RDD.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.variance">
<tt class="descname">variance</tt><big>(</big><em>dtype='float64'</em>, <em>casting='safe'</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of values, ignoring keys</p>
<p>If dtype is not None, then the values will first be cast to the requested type before the operation is
performed. See Data.astype() for details.</p>
</dd></dl>

<dl class="method">
<dt id="thunder.TimeSeries.zscore">
<tt class="descname">zscore</tt><big>(</big><em>axis=0</em><big>)</big><a class="headerlink" href="#thunder.TimeSeries.zscore" title="Permalink to this definition">¶</a></dt>
<dd><p>Zscore series data by subtracting the mean and
dividing by the standard deviation either
within or across records</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> : int, optional, default = 0</p>
<blockquote class="last">
<div><p>Which axis to zscore along, rows (0) or columns (1)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/generated/thunder.TimeSeries.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>